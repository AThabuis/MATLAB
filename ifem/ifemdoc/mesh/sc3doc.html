<!DOCTYPE html>
<html>
<head><meta charset="utf-8" />
<title>sc3doc</title><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<style type="text/css">
/* Overrides of notebook CSS for static HTML export */
body {
  overflow: visible;
  padding: 8px;
}
div#notebook {
  overflow: visible;
  border-top: none;
}@media print {
  div.cell {
    display: block;
    page-break-inside: avoid;
  } 
  div.output_wrapper { 
    display: block;
    page-break-inside: avoid; 
  }
  div.output { 
    display: block;
    page-break-inside: avoid; 
  }
}
</style>

<!-- Custom stylesheet, it must be in the parent directory as the html file -->
<link rel="stylesheet" type="text/css" media="all" href="../doc.css" />
<link rel="stylesheet" type="text/css" media="all" href="doc.css" />

<!-- Loading mathjax macro -->
<!-- Load mathjax -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
    <!-- MathJax configuration -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true,
            processEnvironments: true
        },
        // Center justify equations in code and markdown cells. Elsewhere
        // we use CSS to left justify single line equations in code cells.
        displayAlign: 'center',
        "HTML-CSS": {
            styles: {'.MathJax_Display': {"margin": 0}},
            linebreaks: { automatic: true }
        }
    });
    </script>
    <!-- End of mathjax configuration --></head>
<body>
  <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Simplicial-Complex-in-Three-Dimensions">Simplicial Complex in Three Dimensions<a class="anchor-link" href="#Simplicial-Complex-in-Three-Dimensions">&#182;</a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We dsecribe the data structure of the simplicial complex associated to a three dimensional trianglulation give by <code>node,elem</code> . The <code>node</code> records
the coordinates of vertices and <code>elem</code> is the pointer from local to
global incices of vertices. See <a href="meshbasicdoc.html">Basic mesh data structure</a>.</p>
<p>A brief summary.</p>
<ul>
<li><p><code>edge</code>: asecond ordering, i.e. <code>edge(:,1)&lt;edge(:,2)</code></p>
</li>
<li><p><code>face</code>: asecond ordering, i.e. <code>face(:,1)&lt;face(:,2)&lt;face(:,3)</code></p>
</li>
<li><p><code>elem</code>: either the positive ordering or the ascend ordering. The default one is the positive ordering and the asecond ordering is mainly used for edge and face elements.</p>
</li>
<li><p>Use <code>[elem,bdFlag] = sortelem3(elem,bdFlag)</code> to change the ordering to the ascend ordering. Note that <code>bdFlag</code> should be switched together.</p>
</li>
</ul>
<blockquote><p>The multigrid solvers use the original ordering of <code>elem</code> obtained from either uniform refinement or bisection methods. So let <code>elemold=elem</code> before sort.</p>
</blockquote>
<ul>
<li>Examples on the usage: <code>Poisson3RT0; Maxwell; Maxwell2;</code></li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Outline">Outline<a class="anchor-link" href="#Outline">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The basic data structure of a mesh consists of <code>node</code> and <code>elem</code>. The corresponding simplicial complex consists of vertices, edges, faces, and tetrahedron. We shall discuss three issues</p>
<ul>
<li><em>Indexing</em> of simplexes</li>
<li><em>Ordering</em> of vertices</li>
<li><em>Orientation</em> of simplexes</li>
</ul>
<p>The indexing and ordering are related and the ordering and orientation
are mixed together. However the indexing has nothing to do with the
orientation. The indexing and ordering are the combinarotry structure,
i.e. only <code>elem</code> is needed, while the orientation also depends on <code>node</code>,
the geometry emembdding of vertices.</p>
<p>For indexing, ordering and orientation, there are always local and global versions. The relation between the local and global version is the most complicated issue.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Indexing-of-Simplexes">Indexing of Simplexes<a class="anchor-link" href="#Indexing-of-Simplexes">&#182;</a></h2><p>The indexing refers to the numbering of simplexes, e.g., which face is
numbered as the first one. There are two types of the indexing: local and
global. Each simplex in the simplicial complex has a unique index which
is called the global index. In one tetrahedra, the four vertices and four
faces have their local index from 1:4.</p>
<p>In the assembling procedure of finite element methods, an element-wise
matrix using the local indexing is first computed and then assembled to get a
big matrix using the global indexing. Thus the pointer from the local
indexing to the global indexing is indispensible. For bases independent of
the ordering and orientation, e.g., <code>P1</code> and <code>P2</code> elements, this pointer
is sufficient, otherwise, the inconsistency of the local ordering/orientation
and the global ordering/orientation should be taken into account.</p>
<h3 id="Local-indexing">Local indexing<a class="anchor-link" href="#Local-indexing">&#182;</a></h3><p>The tetrahedron consists of four vertices indexed as [1 2 3 4]. Each
tetrahedron contains four faces and six edges. They can be indexed as</p>

<pre><code>locFace = [2 3 4; 1 3 4; 1 2 4; 1 2 3];
locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4];

</code></pre>
<p>In <code>locFace</code>, the i-th face is opposite to the i-th vertices and thus
this is called <em>opposite indexing</em>. In <code>locEdge</code>, it is the
<em>lexicographic indexing</em> which is induced from the lexicographic ordering
of the six edges. The ordering of vertices of each face or edge will not
change the indexing. For example, the following <code>locFacec</code> and <code>locEdged</code>
has the same indexing as <code>locFace</code> and <code>locEdge</code> but a different ordering
of vertices.</p>

<pre><code>locFacec = [2 3 4; 1 4 3; 1 2 4; 1 3 2];
locEdge = [2 1; 3 1; 4 1; 3 2; 4 2; 4 3];

</code></pre>
<p>Indeed any permuation of each simplex will represent the same simplex and
will not change the indexing. The ordering of vertices will affect the
orientation and will be discussed later.</p>
<p>For a face consists of three vertices [1 2 3], there are two indexing
schemes of its three edges.</p>
<ul>
<li>Oppoiste indexing:        <code>[2 3; 3 1; 1 2]</code></li>
<li>Lexicographic indexing:   <code>[1 2; 1 3; 2 3]</code></li>
</ul>
<p>Each indexing scheme has its advantange and disadavantange and which one
to chose depends on the consideration of ordering and orientation.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Global-indexing-and-vertex-pointers">Global indexing and vertex pointers<a class="anchor-link" href="#Global-indexing-and-vertex-pointers">&#182;</a></h3><p>Each simplex in the simplicial complex has a unqiue index. It is
represented by vertices pointer from the local index to the globa index
of vertices.</p>
<p>The matrix <code>elem</code> is the pointer from local to global indices of vertices
of tetrahedron, e.g. <code>elem(t,1)=25</code> means the first vertex of the
tetrahedron t is the 25-th vertex.</p>
<p>Similarly the <code>NE x 2</code> matrix <code>edge</code> records all edges and the <code>NF x 3</code> by 3
matrix <code>face</code> records all faces of the triangulation. These are vertices
pointers. We shall discuss the elementwise pointer from the local indices to
the global indices for edges and faces.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[16]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="n">elem</span><span class="p">]</span> <span class="p">=</span> <span class="n">cubemesh</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">);</span>
<span class="n">showmesh3</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">elem</span><span class="p">,[],</span><span class="s">&#39;FaceAlpha&#39;</span><span class="p">,</span><span class="mf">0.25</span><span class="p">);</span>
<span class="n">findelem3</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">elem</span><span class="p">);</span>
<span class="n">findnode3</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">elem</span><span class="p">(:));</span>
<span class="n">display</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>
elem =

     1     2     3     7
     1     4     3     7
     1     5     6     7
     1     5     8     7
     1     2     6     7
     1     4     8     7

</pre>
</div>
</div>

<div class="output_area">

<div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
HGWtSqklyboq9skHn8zl61KJgAwIJMSU2zMskq6KdVuPqERAVgQSYi3DJbSpJcleQHKeRlQiwDkC
CfD/FFpyCPCAQAJEuqhKabfbZa5HTM0BnhFIwBFpq1LF6Arrg7IZZVYatTW2/Xr2ryf/bPLIr4y0
nqISAbkjkICjJG52SFI1rUpE7v3Rvbt279pYt7HtJ21CJQL8k8c3EpBWUiaVjCmx7qBa3VD96opX
7//f91uP8x0E+IVAAtJI25CS1NbWfv3rXw9hMEBM5Ec9AEA/Dz30UNRDAAxEIAEAlEAgAQCUQCAB
aWRYW2XZFQgIgQQAUALXIQHppV6QRDcCAkUgAZkQQkBomLIDACiBQAJc2717t4i0trZGPRDAKNyp
AXBh8uTJH3/8cV1dXVtb2zHHHHPhhRcOHTp0yZIlUY8LMAGBBABQAlN2AAAlEEgAACUQSAAAJRBI
AAAlEEgAACUQSAAAJRBIAAAlEEgAACUQSAAAJRBIAAAlEEgAACUQSAAAJRBIAAAlEEgAACUQSAAA
JRBIAAAlEEgAACUQSAAAJRBIAAAlEEgAACUQSAAAJRBIAAAlEEgAACUQSAAAJRBIAAAlEEgAACUQ
SAAAJRBIAAAlEEgAACUQSAAAJRBIAAAlEEgAACUQSAAAJRBIAAAlEEgAACUQSAAAJfx/kKTm5gy8
bJcAAAAASUVORK5CYII=
"
>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Generate-index-pointers-for-edges-and-faces">Generate index pointers for edges and faces<a class="anchor-link" href="#Generate-index-pointers-for-edges-and-faces">&#182;</a></h3><p>One can easily collect edges and faces elementwise. The issue is the
duplication. For example, each interior face will be counted twice. The
<code>unique</code> function is applied such that each edge or face has a unique
global index.</p>
<p><strong>Edge and Face</strong></p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[17]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">totalEdge</span> <span class="p">=</span> <span class="n">uint32</span><span class="p">([</span><span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">4</span><span class="p">]);</span> <span class="c">...</span>
                    <span class="n">elem</span><span class="p">(:,[</span><span class="mi">2</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">2</span> <span class="mi">4</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">3</span> <span class="mi">4</span><span class="p">])]);</span>
<span class="n">sortedTotalEdge</span> <span class="p">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">totalEdge</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="p">[</span><span class="n">edge</span><span class="p">,</span> <span class="o">~</span><span class="p">,</span> <span class="n">je</span><span class="p">]</span> <span class="p">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">sortedTotalEdge</span><span class="p">,</span><span class="s">&#39;rows&#39;</span><span class="p">);</span>
<span class="n">display</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>

<span class="n">totalFace</span> <span class="p">=</span> <span class="n">uint32</span><span class="p">([</span><span class="n">elem</span><span class="p">(:,[</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">4</span> <span class="mi">3</span><span class="p">]);</span> <span class="c">...</span>
                    <span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">])]);</span>
<span class="n">sortedTotalFace</span> <span class="p">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">totalFace</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>                
<span class="p">[</span><span class="n">face</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">jf</span><span class="p">]</span> <span class="p">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">sortedTotalFace</span><span class="p">,</span><span class="s">&#39;rows&#39;</span><span class="p">);</span>
<span class="n">display</span><span class="p">(</span><span class="n">face</span><span class="p">);</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>
edge =

  19�2 uint32 matrix

   1   2
   1   3
   1   4
   1   5
   1   6
   1   7
   1   8
   2   3
   2   6
   2   7
   3   4
   3   7
   4   7
   4   8
   5   6
   5   7
   5   8
   6   7
   7   8


face =

  18�3 uint32 matrix

   1   2   3
   1   2   6
   1   2   7
   1   3   4
   1   3   7
   1   4   7
   1   4   8
   1   5   6
   1   5   7
   1   5   8
   1   6   7
   1   7   8
   2   3   7
   2   6   7
   3   4   7
   4   7   8
   5   6   7
   5   7   8

</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In iFEM, <code>N,NE,NF,NT</code> represents the number of vertices, edges, faces and tetrahedrons, resprectively.</p>

<pre><code>N = size(node,1); NT = size(elem,1); NF = size(face,1); NE = size(edge,1);

</code></pre>
<p>In the assembling procedure, the matrix is always computed elementwise and then assemble to a big one. A pointer from the local index of a simplex to its global index is thus indispensible.</p>
<p><strong>Elementwise pointers</strong></p>
<ul>
<li><code>elem2node = elem</code></li>
<li><code>elem2face(1:NT, 1:4)</code></li>
<li><code>elem2edge(1:NT, 1:6)</code></li>
</ul>
<p>Such information is exactly stored in the output of <code>unique</code> function. For example, <code>elem2face(t,1) = 17</code> means the first face of t (spanned by <code>[2 3 4]</code>) is the 17-th element in the <code>face</code> matrix.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[18]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">N</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="n">NT</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="n">NF</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">face</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="n">NE</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">elem2edge</span> <span class="p">=</span> <span class="n">uint32</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">je</span><span class="p">,</span><span class="n">NT</span><span class="p">,</span><span class="mi">6</span><span class="p">));</span>
<span class="n">elem2face</span> <span class="p">=</span> <span class="n">uint32</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">jf</span><span class="p">,</span><span class="n">NT</span><span class="p">,</span><span class="mi">4</span><span class="p">));</span>
<span class="n">display</span><span class="p">(</span><span class="n">elem2edge</span><span class="p">);</span>
<span class="n">display</span><span class="p">(</span><span class="n">elem2face</span><span class="p">);</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>
elem2edge =

  6�6 uint32 matrix

    1    2    6    8   10   12
    3    2    6   11   13   12
    4    5    6   15   16   18
    4    7    6   17   16   19
    1    5    6    9   10   18
    3    7    6   14   13   19


elem2face =

  6�4 uint32 matrix

   13    5    3    1
   15    5    6    4
   17   11    9    8
   18   12    9   10
   14   11    3    2
   16   12    6    7

</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Face to edge Pointer</strong></p>
<p><code>face2edge(1:NF,1:3)</code> records the global indices of three edges of a
face. This pointer depends on the ordering of vertices of faces and the
indexing of local edges in a face. We list the following two important
cases. Other combinations is possible but not attractive.</p>
<ul>
<li>Ascend ordering.</li>
</ul>
<p>All local faces and local edges are ascend ordered.</p>

<pre><code>locFace = [2 3 4; 1 3 4; 1 2 4; 1 2 3];
locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4];
edgeOfFace = [1 2; 1 3; 2 3];
locFace2edge = [4 5 6; 2 3 6; 1 3 5; 1 2 4];

</code></pre>
<ul>
<li>Consistent ordering</li>
</ul>
<p>The local face is ordered such that the corresponding orientation is
consistent with the induced orientation.</p>

<pre><code>locFace = [2 3 4; 1 4 3; 1 2 4; 1 3 2];
locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4];
edgeOfFace = [2 3; 3 1; 1 2];   
locFace2edge = [6 5 4; 6 2 3; 5 3 1; 4 1 2];

</code></pre>
<p>The global one can be obtained from the composition of <code>elem2face</code> and
<code>locFace2edge</code>. For example, for the asecnd ordering scheme,</p>

<pre><code>face2edge(elem2face(:,1),:) = elem2edge(:,[4 5 6]);
face2edge(elem2face(:,2),:) = elem2edge(:,[2 3 6]);
face2edge(elem2face(:,3),:) = elem2edge(:,[1 3 5]);
face2edge(elem2face(:,4),:) = elem2edge(:,[1 2 4]);</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Ordering-of-Vertices">Ordering of Vertices<a class="anchor-link" href="#Ordering-of-Vertices">&#182;</a></h2><p>We discuss the ordering of vertices of simplexes. Again there are local
ordering and global ordering. They may not be consistent and a sign array
is used to record the inconsistency if any.</p>
<p>The local ordering refers to the ordering of vertices in <code>locFace</code> or
<code>locEdge</code>, i.e. the ordering of the local index of vertices. For elements
associated to faces or edges, the local ordering could be used in the
formulation of the local basis and thus the ordering does matter.</p>
<p>The global ordering refers to the ordering of vertices in <code>face</code> or
<code>edge</code>, i.e., the ordering of the global index of vertices. Note that
that in either local or global ordering, permutation of vertices will
represent the same simplex. To fix an ordering we need extra information.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="elem">elem<a class="anchor-link" href="#elem">&#182;</a></h3><p>The local ordering is always [1 2 3 4]. Any permutation of four vertices of a tetrahedon still represents the same tetrahedron. Such freedom provide a room to record more information like:</p>
<ul>
<li>global ordering of vertices</li>
<li>an orientation of element</li>
<li>refinement rules (uniform refinement or bisection)</li>
</ul>
<p>For 2-D triangulations, three vertices of a triangle in 2-D is sorted counter-cloclwise and the first vertex is chosen as the newest vertex. Such ordering enables the efficient implementation of local refinement
and coarsening in 2-D; see <a href="../afem/bisectdoc.html">Bisection in Two Dimensions</a>
and <a href="../afem/coarsendoc.html">Coarsening in Two Dimensions</a>.</p>
<p>In 3-D, for the longest edge bisection, the newest vertex (with the highest generation) is stored as the last (4-th) vertex of a tetrahedron. For <a href="uniformrefine3doc.html">3-D Red Refinement</a>, the ordering determines the shape regularity of refined triangulation. Permuation of vertices in <code>elem</code> could deterioriate the angle condition after the refinement.</p>
<p>We shall reserve the ordering of <code>elem</code> from the mesh refinement and
coarsening since they are more subtle. We switch the ordering when
generating data structure for finite element basis and assemble the
matrix equation. Such sorting is hidden in the subroutines when a finite
element basis requiring ordering is generated.</p>
<p>Two types of ordering of <code>elem</code> is of particular importantance</p>
<ul>
<li>Ascend ordering</li>
<li>Positive ordering</li>
</ul>
<p>In the ascend ordering, the vertices of <code>elem</code> is sorted such that</p>

<pre><code>elem(t,1) &lt; elem(t,2) &lt; elem(t,3) &lt; elem(t,4). 

</code></pre>
<p>Such ordering will benefit the construction of local bases for high order basis or basis with orientation. This can be easily achieved by <code>elem = sort(elem,2)</code>. One has to rotate the boundary flag accordingly.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[22]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">bdFlag</span> <span class="p">=</span> <span class="n">setboundary3</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">elem</span><span class="p">,</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">);</span>
<span class="p">[</span><span class="n">elem</span><span class="p">,</span><span class="n">bdFlag</span><span class="p">]</span> <span class="p">=</span> <span class="n">sortelem3</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span><span class="n">bdFlag</span><span class="p">);</span>    
<span class="n">display</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>
elem =

     1     2     3     7
     1     3     4     7
     1     5     6     7
     1     5     7     8
     1     2     6     7
     1     4     7     8

</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In the positive ordering, the four vertices are ordered such that the
signed volume, the mix product of vectors (v12,v13,v14), is positive.
This is the default ordering used so far. <code>fixorder3</code> will switch the
vertices for elements with negative volume.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[25]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">elem</span> <span class="p">=</span> <span class="n">fixorder3</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">elem</span><span class="p">)</span>   <span class="c">% switchs the vertices for elements with negative volume.</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>
elem =

     1     2     3     7
     1     3     4     7
     1     5     6     7
     1     5     7     8
     1     6     2     7
     1     7     4     8

</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="edge">edge<a class="anchor-link" href="#edge">&#182;</a></h3><p>For 3-D triangulations, we chose the ascend ordering both locally and globally. Namely</p>

<pre><code>locEdge(:,1) &lt; locEdge(:,2); 
   edge(:,1) &lt; edge(:,2);

</code></pre>
<p>Recall that for <code>locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4]</code>, it is ascend
ordered. The <code>edge</code> produced by <code>unique</code> function is also ascend
ordered.</p>
<p>There might be inconsistency between the local and global ordering.
That is <code>edge(elem2edge(t,1),1)</code> may not be smaller than <code>edge(elem2edge(t,1),2)</code>. It will be more clear from the discussion of the corresponding orientation.</p>
<p>For 2-D triangulations, the global ordering is still ascend ordered. But locally it may not. For example, for the consisitent ordering <code>locEdge = [2 3; 3 1; 1 2]</code>, then <code>locEdge(2,1) &gt; locEdge(2,2)</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="face">face<a class="anchor-link" href="#face">&#182;</a></h3><p>For 3-D triangulations, the <code>face</code> produced by <code>unique</code> function is already sorted in the second dimension such that the global ordering is ascended i.e. <code>face(:,1) &lt; face(:,2) &lt; face(:,3)</code>. The local ordering in <code>locFace</code>, however, is not always ascend ordered.</p>

<pre><code>locFace = [2 3 4; 1 3 4; 1 2 4; 1 2 3]; % Ascend ordering
locFace = [2 3 4; 1 4 3; 1 2 4; 1 3 2]; % Consistent ordering

</code></pre>
<p>Again the local and the global ordering maynot be consisitent. That is</p>

<pre><code>face(elem2face(t,:),1) &lt; face(elem2face(t,:),2) &lt; face(elem2face(t,:),3)

</code></pre>
<p>maynot be always true unless we use the ascend ordering in both <code>face</code> and <code>locFace</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Orientation">Orientation<a class="anchor-link" href="#Orientation">&#182;</a></h2><p>The orientation of a tetrahedron is either positive or negative. The
orientation of a face is given by a normal vector and the orientation of
an edge is determined by a tangential vector.</p>
<p>The orientation of a d-simplex will induce an orientation of its d-1 boundary
subcomplex and is called the <em>induced orientation</em>. For example, a positive
orientated tetrahedron will induce the outwards normal orientation of its
four faces and a positive orientated triangle will induce the counter
clockwise orientation of its three edges.</p>
<p>The ordering of vertices of a simplex will naturally introduce an
orientation and will be called the <em>ordering orientation</em>. More specifically</p>
<ul>
<li>the vector from <code>edge(:,1)</code> to <code>edge(:,2)</code> defines an orientation of edges.</li>
<li>the <code>cross(v12,v13)</code> defines an orientation of a face, where <code>vij</code> is
the vector from vertex <code>face(:,i)</code> to <code>face(:,j)</code>.</li>
<li>the sign of the mix product <code>sign(v12, v13, v14)</code> defines an orientation for tetrahedrons.</li>
</ul>
<p>The orientation of a simplex in the simplicial complex should be uniquely
determined which will be called the <em>global orientation</em>. It can be chosen as
the global ordering orientation but not always.</p>
<p>Inside one tetrahedron, the local ordering of local edges and local faces
will introduce a corresponding orientation. The orientation of the
tetrahedron will also induce an orientation for its four faces. These are
called the <em>local orientation</em> which may not be consisitent with the global
orientation. The local ordering orientation is used in the local basis and the induced orientation is used when computing the differential operator locally.</p>
<p>In general, there will be an inconsistency of different types of orientation and apporipate data structure should be constructured to record such inconsistency.</p>
<ul>
<li>a global orientation</li>
<li>the global ordering orientation</li>
<li>the local ordering orientation inside a tetrahedron</li>
<li>the local induced orientation inside a tetrahedron</li>
</ul>
<p>We now discuss the orientation of elem, face, and edge separately.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="elem">elem<a class="anchor-link" href="#elem">&#182;</a></h3><p>The orientation of a tetraheron is either positive or negative.
We chose the global ordering orientation, i.e., the sign of the signed
volume computed from <code>elem</code>.</p>

<pre><code>[Dlambda,volume,elemSign] = gradbasis3(node,elem);

</code></pre>
<p>In the output of <code>gradbasis3</code>, <code>volume</code> is always positive and an
additional array <code>elemSign</code> is used to record the sign of the signed
volume.</p>
<p><code>Dlambda(t,:,k)</code> is the gradient of $\lambda_k$ associated to vertex $k$. Therefore the outward normal direction of the kth face is <code>-Dlambda(t,:,k)</code> which is independent of the ordering and orientation of the element.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="face">face<a class="anchor-link" href="#face">&#182;</a></h3><p>Again we use the global ordering orientation determined by <code>face</code>. The normal vector is given by <code>cross(v12,v13)</code>.</p>
<p>The local ordering orientation is implicitly used when computing finite element basis in each element. For example, the RT0 basis on face <code>[i j k]</code> in <code>locFace</code> is defined as</p>
$$\phi_{i,j,k} = 2(\lambda_i \nabla \lambda_j \times \nabla \lambda_k+ \lambda_j \nabla \lambda_k \times \nabla \lambda_i+\lambda_k \nabla \lambda_i \times \nabla \lambda_j).$$<p></p>
<p>Odd permutation of <code>[i j k]</code> will change the sign of the basis. The direction of $\phi_{i,j,k}$ is the normal vector determined by <code>[i,j,k]</code> ordering. Note that this is defined locally, i.e., element by element.</p>
<p>The global basis associated to a face, however, depends only on the global orientation of this face. We introduce <code>elem2faceSign(1:NT, 1:4)</code> to record the inconsistency of a local ordering orientation and a global orientation.</p>
<p>For <code>locFace = [2 3 4; 1 4 3; 1 2 4; 1 3 2]</code>, i.e. the induced orientation, the <code>elem2faceSign</code> can be obtained from subroutine <code>dof3face</code> follows</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[27]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">totalFace</span> <span class="p">=</span> <span class="p">[</span><span class="n">elem</span><span class="p">(:,[</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">4</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">])];</span>
<span class="n">elem2faceSign</span> <span class="p">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">sum</span><span class="p">(</span><span class="nb">sign</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">totalFace</span><span class="p">(:,[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span><span class="mi">2</span><span class="p">),</span><span class="n">NT</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>
elem2faceSign =

     1    -1     1    -1
     1    -1     1    -1
     1    -1     1    -1
     1    -1     1    -1
    -1    -1     1     1
    -1    -1     1     1

</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>When both <code>elem</code> and <code>locFace</code> are ascend ordered, the orientation of the
global ordering is consistent with that of the local ordering. Thus
<code>elem2faceSign</code> is not needed for the ascending ordering in assembling the mass matrix.</p>
<p>But for the asecond ordering system, an <code>elem2faceSign</code> will be used when assembling differential operators because the orientation for Stokes theorem is induced orientation. For example, when computing <code>div</code> operators on a positive orientated tetrahedron, the faces should be orientated by the outwards normal direction but the global faces may not be.</p>
<p>If <code>elem</code> is positive ordered and <code>locFace</code> is consistently ordered, then this inconsistency is already recorded in <code>elem2faceSign</code>.</p>
<p>For the ascend ordering of <code>elem</code> and <code>locFace</code>, we use $+1$ if the
orientation of a face is the same with the induced outwords normal direction in a certain elem, and $-1$ otherwise. Then the inconsistency is given by <code>elem2faceSign = [1 -1 1 -1]</code> by comparing</p>
<ul>
<li>The induced orientation: <code>locFace = [2 3 4; 1 4 3; 1 2 4; 1 3 2]</code>;</li>
<li>The ascend orientation:    <code>locFace = [2 3 4; 1 3 4; 1 2 4; 1 2 3]</code>.</li>
</ul>
<p>Here we use the <em>ascend orientation</em> to refer to the orientation given by the ascend ordering.</p>
<p>In summary,</p>
<ul>
<li>the induced orientation is favorable for computing $d\phi$;</li>
<li>the asecond orientation is favorable for computing $(f, \phi)$ or $(\phi_i, \phi_j)$.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="edge">edge<a class="anchor-link" href="#edge">&#182;</a></h3><p>The orientation of edges is simpler than faces. Globally we always chose the global ascend ordering orientation. Namely the orientation of an edge is from the vertex with the smaller index to the larger one.</p>
<p>Locally the local ascend ordering may not be consistent with the global one. See Lowest Order Edge Element. For the ascend ordering of <code>elem</code> and <code>locEdge</code>, the local and the global
orientation will be consistent and no <code>elem2edgeSign</code> is needed!</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[28]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">totalEdge</span> <span class="p">=</span> <span class="n">uint32</span><span class="p">([</span><span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">4</span><span class="p">]);</span> <span class="c">...</span>
                    <span class="n">elem</span><span class="p">(:,[</span><span class="mi">2</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">2</span> <span class="mi">4</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">3</span> <span class="mi">4</span><span class="p">])]);</span>
<span class="n">direction</span> <span class="p">=</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">NT</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;int8&#39;</span><span class="p">);</span>
<span class="n">idx</span> <span class="p">=</span> <span class="p">(</span><span class="n">totalEdge</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="n">totalEdge</span><span class="p">(:,</span><span class="mi">2</span><span class="p">));</span>
<span class="n">direction</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">elem2edgeSign</span> <span class="p">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span><span class="n">NT</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>
elem2edgeSign =

  6�6 int8 matrix

    1    1    1    1    1    1
    1    1    1    1    1    1
    1    1    1    1    1    1
    1    1    1    1    1    1
    1    1    1   -1    1    1
    1    1    1   -1    1    1

</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="face-to-edge">face to edge<a class="anchor-link" href="#face-to-edge">&#182;</a></h3><p>For the ascend ordering <code>edgeofFace = [1 2; 1 3; 2 3]</code>, the local and the global ordering is consistent and so is the ordering orientation.</p>
<p>Then it is not consisitent with the induced positive (counter clockwise) orientation of edges. When the edge direction is the same with the induced direction, we use sign $+1$, otherwise $-1$. Then <code>face2edgeSign = [+1 -1 +1]</code> records the inconsistency of the ascend orientation of the induced orientation.</p>
<p>For the consistent ordering, <code>edgeofFace = [2 3; 3 1; 1 2]</code> which is consisent with the induced positive orientation but then may not be consistent with the global orientation of edges. We construct <code>face2edgeSign</code> to record such inconsistency</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[30]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">totalEdge</span> <span class="p">=</span> <span class="p">[</span><span class="n">face</span><span class="p">(:,[</span><span class="mi">2</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">face</span><span class="p">(:,[</span><span class="mi">3</span> <span class="mi">1</span><span class="p">]);</span> <span class="n">face</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">])];</span>
<span class="n">direction</span> <span class="p">=</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">NF</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">idx</span> <span class="p">=</span> <span class="p">(</span><span class="n">totalEdge</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="n">totalEdge</span><span class="p">(:,</span><span class="mi">2</span><span class="p">));</span>
<span class="n">direction</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">face2edgeSignp</span> <span class="p">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span><span class="n">NF</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>
face2edgeSignp =

     1    -1     1
     1    -1     1
     1    -1     1
     1    -1     1
     1    -1     1
     1    -1     1
     1    -1     1
     1    -1     1
     1    -1     1
     1    -1     1
     1    -1     1
     1    -1     1
     1    -1     1
     1    -1     1
     1    -1     1
     1    -1     1
     1    -1     1
     1    -1     1

</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Summary">Summary<a class="anchor-link" href="#Summary">&#182;</a></h2><p>We summarize the two popular ordering and orientation schemes below.</p>
<h3 id="Ascend-Odering-and-Orientation">Ascend Odering and Orientation<a class="anchor-link" href="#Ascend-Odering-and-Orientation">&#182;</a></h3><p>The asecond odering and orientation is more algebraic, determined by the indices of vertices.</p>
<h4 id="Ascend-ordering">Ascend ordering<a class="anchor-link" href="#Ascend-ordering">&#182;</a></h4><p>The array <code>elem</code> is sorted such that</p>

<pre><code>elem(i,1) &lt; elem(i,2) &lt; elem(i,3) &lt; elem(i,4)

</code></pre>
<p>The local face and local edges is also in the ascend ordering</p>
<ul>
<li><code>locFace = [2 3 4; 1 3 4; 1 2 4; 1 2 3];</code></li>
<li><code>locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4];</code></li>
<li><code>edgeofFace = [1 2; 1 3; 2 3];</code></li>
</ul>
<p>Then due to the asecond ordering of <code>elem</code>, globally the <code>edge</code> and <code>face</code> also follow the ascend ordering, i.e.</p>
<ul>
<li><code>edge(e,1) &lt; edge(e,2);</code> </li>
<li><code>face(f,1) &lt; face(f,2) &lt; face(f,3).</code> </li>
</ul>
<p>One can easily see the benefit: the ordering of local edges and local faces is consistent with the global ones and so is their corresponding orientation.</p>
<h4 id="Orientation">Orientation<a class="anchor-link" href="#Orientation">&#182;</a></h4><p>We chose the global ordering orientation for each elment. We chose the orientation corresponding to the ascend ordering for edges
and faces. That is</p>
<ul>
<li><code>elem: sign(v12,v13,v14)</code></li>
<li><code>face:</code>  the normal vector is given by <code>cross(v12,v13)</code></li>
<li><code>edge:</code>  from the node with the smaller global index to the bigger one</li>
</ul>
<p>For faces and edges, the orientation of the ascend ordering and the induced orientation is not consistent. The inconsistency is recorded by</p>
<ul>
<li><code>elem2faceSign = [1 -1 1 -1];</code></li>
<li><code>face2edgeSign = [1 -1 1];</code></li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Positive-Ordering-and-Orientation">Positive Ordering and Orientation<a class="anchor-link" href="#Positive-Ordering-and-Orientation">&#182;</a></h3><p>The positive orientation and ordering is more geometrically consistent in the sense that the orientation of an element is locally consistent with the orientation of the local boundary faces. But it introduces inconsistency with the global orientation of a simplex.</p>
<h4 id="Positive-and-consistent-ordering">Positive and consistent ordering<a class="anchor-link" href="#Positive-and-consistent-ordering">&#182;</a></h4><p>The vertices of <code>elem</code> is sorted such that the signed volume is always positive, i.e. the four vertices follows the right hand rule.</p>
<p>The four faces of a tetrahedron are ordered consistently as</p>

<pre><code>locFace = [2 3 4; 1 3 4; 1 2 4; 1 2 3];

</code></pre>
<p>The six edges of a tetrahedron still ascend ordered</p>

<pre><code>locEdge = [1 2; 1 3; 1 4; 2 3; 2 4; 3 4];

</code></pre>
<p>Three edges of a face is ordered consistently</p>

<pre><code>edgeofFace = [2 3; 3 1; 1 2];

</code></pre>
<h4 id="Orientation">Orientation<a class="anchor-link" href="#Orientation">&#182;</a></h4><p>The ascend ordering orientation is used for the global orientation of <code>edge</code> and <code>face</code> arrays. The inconsistency of the local and the global orientation is recorded in
<code>elem2faceSign</code> and <code>elem2edgeSign</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="An-Example">An Example<a class="anchor-link" href="#An-Example">&#182;</a></h3><p>We show two tetrahedron with the ascend ordering.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[34]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="c">% A mesh with two tetrahedron with the ascend ordering</span>
<span class="n">elem</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">8</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">7</span><span class="p">];</span>
<span class="n">node</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">;</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="n">NT</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">showmesh3</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">elem</span><span class="p">,[],</span><span class="s">&#39;FaceAlpha&#39;</span><span class="p">,</span><span class="mf">0.25</span><span class="p">);</span>
<span class="n">findelem3</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">elem</span><span class="p">);</span>
<span class="n">findnode3</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">elem</span><span class="p">(:));</span>
<span class="n">display</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
<span class="c">% generate edge array</span>
<span class="n">totalEdge</span> <span class="p">=</span> <span class="n">uint32</span><span class="p">([</span><span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">4</span><span class="p">]);</span> <span class="c">...</span>
                    <span class="n">elem</span><span class="p">(:,[</span><span class="mi">2</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">2</span> <span class="mi">4</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">3</span> <span class="mi">4</span><span class="p">])]);</span>
<span class="n">sortedTotalEdge</span> <span class="p">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">totalEdge</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="p">[</span><span class="n">edge</span><span class="p">,</span> <span class="o">~</span><span class="p">,</span> <span class="n">je</span><span class="p">]</span> <span class="p">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">sortedTotalEdge</span><span class="p">,</span><span class="s">&#39;rows&#39;</span><span class="p">);</span>
<span class="n">display</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
<span class="c">% generate face array</span>
<span class="n">totalFace</span> <span class="p">=</span> <span class="n">uint32</span><span class="p">([</span><span class="n">elem</span><span class="p">(:,[</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">4</span> <span class="mi">3</span><span class="p">]);</span> <span class="c">...</span>
                    <span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">]);</span> <span class="n">elem</span><span class="p">(:,[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">])]);</span>
<span class="n">sortedTotalFace</span> <span class="p">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">totalFace</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>                
<span class="p">[</span><span class="n">face</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">jf</span><span class="p">]</span> <span class="p">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">sortedTotalFace</span><span class="p">,</span><span class="s">&#39;rows&#39;</span><span class="p">);</span>
<span class="n">display</span><span class="p">(</span><span class="n">face</span><span class="p">);</span>
<span class="c">% generate pointers of indices</span>
<span class="n">elem2edge</span> <span class="p">=</span> <span class="n">uint32</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">je</span><span class="p">,</span><span class="n">NT</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">elem2face</span> <span class="p">=</span> <span class="n">uint32</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">jf</span><span class="p">,</span><span class="n">NT</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="c">% find orientation of elem</span>
<span class="p">[</span><span class="n">v</span><span class="p">,</span><span class="n">elemSign</span><span class="p">]</span> <span class="p">=</span> <span class="n">simplexvolume</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">elem</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>
elem =

     1     4     5     8
     1     4     5     7


edge =

  9�2 uint32 matrix

   1   4
   1   5
   1   7
   1   8
   4   5
   4   7
   4   8
   5   7
   5   8


face =

  7�3 uint32 matrix

   1   4   5
   1   4   7
   1   4   8
   1   5   7
   1   5   8
   4   5   7
   4   5   8


elem2edge =

  2�6 uint32 matrix

   1   2   4   5   7   9
   1   2   3   5   6   8


elem2face =

  2�4 uint32 matrix

   7   5   3   1
   6   4   2   1


v =

    0.6667
    0.6667


elemSign =

    -1
     1

</pre>
</div>
</div>

<div class="output_area">

<div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
tCKQwhuZdOjQodmzZ4+NjbV/paTJHhLQdnXeqa/vtL7JmRRC2Lhxoz2kIhBIQAomIqo8mSan0dat
W0MId9xxx6233tqxtZEWIzsgTVWrUrmFCxc+8MADxx13XGfWQ4q60l4AUGg1fideu3Ztb2/v7t27
3/e+9917772dXBWp0JCAlE1VksbHx0dGRq644oo77rijt7f3ySef1JPyTUMCUjY+Pl7xm/GmTZuS
d+bOnXv77bdv2LBhdHR0eHg4pQXSIRoSEJFXXnnlmGOOOXjwYFfXm35d/vjHP37cccfdcsstaS2M
DtCQgIgcffTRs2bN2rt3b8X7vb29S5YsSWVJdIxAAiLS1dU1MDCwcuXK8jf37t372GOPfe5zn0tr
VXSGkR0Ql/37919++eV79+794he/OHv27N27d991113f/e53Fy9enPbSaC+BBMRo9+7dDz744P79
++fPn3/++eenvRw6QSABEAV7SABEQSABEAWBBEAUBBIAURBIAERBIAEQBYEEQBQEEgBREEgAREEg
ARAFgQRAFAQSAFEQSABEQSABEAWBBEAUBBIAURBIAERBIAEQBYEEQBQEEgBREEgAREEgARAFgQRA
FAQSAFEQSABEQSABEAWBBEAUBBIAURBIAERBIAEQBYEEQBQEEgBREEgAREEgARAFgQRAFAQSAFEQ
SABEQSABEAWBBEAUBBIAURBIAERBIAEQBYEEQBQEEgBREEgAREEgARAFgQRAFAQSAFEQSABEQSAB
EAWBBEAUBBIAURBIAERBIAEQBYEEQBQEEgBREEgAREEgARAFgQRAFAQSAFEQSABEQSABEAWBBEAU
BBIAURBIAERBIAEQBYEEQBQEEgBREEgAREEgARAFgQRAFAQSAFEQSABEQSABEAWBBEAUBBIAURBI
AERBIAEQBYEEQBQEEgBREEgAREEgARAFgQRAFAQSAFEQSABEQSABEAWBBEAUBBIAURBIAERBIAEQ
BYEEQBQEEgBREEgAREEgARAFgQRAFAQSAFH4fwLPP2uQ2CHGAAAAAElFTkSuQmCC
"
>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Since we are using the ascend ordering, the inconsistency with the induced orientation is</p>
<ul>
<li><code>elem2faceSign = [1 -1 1 -1];</code></li>
<li><code>face2edgeSign = [1 -1 1];</code></li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Boundary-Faces-and-Boundary-Conditions">Boundary Faces and Boundary Conditions<a class="anchor-link" href="#Boundary-Faces-and-Boundary-Conditions">&#182;</a></h2><p>We use <code>bdFlag</code> to record the boundary condition; see <a href="bddoc.html">Data Structure: Boundary Conditions</a> for details. For short, <code>bdFlag</code> has the same size with <code>elem</code>, and records the boundary type of each local faces. If we change the ordering of <code>elem</code>, the corresponding local faces are changed. Threfore when we sort the <code>elem</code>, we should sort the <code>bdFlag</code> respectively. We use <code>sortelem3</code> to sort <code>elem</code> and <code>bdFlag</code> at the same time. Note that <code>sort(elem,2)</code> sorts the <code>elem</code> only, and leave
<code>bdFlag</code> unchanged.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[35]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="n">elem</span><span class="p">]</span> <span class="p">=</span> <span class="n">cubemesh</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">);</span>
<span class="n">bdFlag</span> <span class="p">=</span> <span class="n">setboundary3</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">elem</span><span class="p">,</span><span class="s">&#39;Dirichlet&#39;</span><span class="p">,</span><span class="s">&#39;x==1&#39;</span><span class="p">,</span><span class="s">&#39;Neumann&#39;</span><span class="p">,</span><span class="s">&#39;x~=1&#39;</span><span class="p">);</span>
<span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">clf</span><span class="p">;</span>
<span class="n">showmesh3</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">elem</span><span class="p">);</span>
<span class="n">display</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span> <span class="n">display</span><span class="p">(</span><span class="n">bdFlag</span><span class="p">);</span>
<span class="n">findnode3</span><span class="p">(</span><span class="n">node</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]);</span>
<span class="n">display</span><span class="p">(</span><span class="s">&#39;change to ascend ordering&#39;</span><span class="p">);</span>
<span class="p">[</span><span class="n">elem</span><span class="p">,</span><span class="n">bdFlag</span><span class="p">]</span> <span class="p">=</span> <span class="n">sortelem3</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span><span class="n">bdFlag</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>
elem =

     1     2     3     7
     1     4     3     7
     1     5     6     7
     1     5     8     7
     1     2     6     7
     1     4     8     7


bdFlag =

  6�4 uint8 matrix

   1   0   0   2
   2   0   0   2
   2   0   0   2
   2   0   0   2
   1   0   0   2
   2   0   0   2

change to ascend ordering

elem =

     1     2     3     7
     1     3     4     7
     1     5     6     7
     1     5     7     8
     1     2     6     7
     1     4     7     8


bdFlag =

  6�4 uint8 matrix

   1   0   0   2
   2   0   0   2
   2   0   0   2
   2   0   2   0
   1   0   0   2
   2   0   2   0

</pre>
</div>
</div>

<div class="output_area">

<div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
AElFTkSuQmCC
"
>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can use <code>bdFlag</code> to find the boundary nodes, edges and faces. To find the outwords normal direction of the boundary face, we use <code>gradbasis3</code> to get <code>Dlambda(t,:,k)</code> which is the gradient of $\lambda_k$. The outward normal direction of the kth face can be obtained by <code>-Dlambda(t,:,k)</code> which is independent of the ordering and orientation of <code>elem</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[36]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-matlab"><pre><span></span><span class="n">Dlambda</span> <span class="p">=</span> <span class="n">gradbasis3</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">elem</span><span class="p">);</span>
<span class="n">T</span> <span class="p">=</span> <span class="n">auxstructure3</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
<span class="n">elem2face</span> <span class="p">=</span> <span class="n">T</span><span class="p">.</span><span class="n">elem2face</span><span class="p">;</span> 
<span class="n">face</span> <span class="p">=</span> <span class="n">T</span><span class="p">.</span><span class="n">face</span><span class="p">;</span>
<span class="n">NF</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">face</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">if</span> <span class="o">~</span><span class="nb">isempty</span><span class="p">(</span><span class="n">bdFlag</span><span class="p">)</span>
    <span class="c">% Find Dirchelt boundary faces and nodes</span>
    <span class="n">isBdFace</span> <span class="p">=</span> <span class="n">false</span><span class="p">(</span><span class="n">NF</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">isBdFace</span><span class="p">(</span><span class="n">elem2face</span><span class="p">(</span><span class="n">bdFlag</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="p">=</span> <span class="n">true</span><span class="p">;</span>
    <span class="n">isBdFace</span><span class="p">(</span><span class="n">elem2face</span><span class="p">(</span><span class="n">bdFlag</span><span class="p">(:,</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="p">=</span> <span class="n">true</span><span class="p">;</span>
    <span class="n">isBdFace</span><span class="p">(</span><span class="n">elem2face</span><span class="p">(</span><span class="n">bdFlag</span><span class="p">(:,</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="p">=</span> <span class="n">true</span><span class="p">;</span> 
    <span class="n">isBdFace</span><span class="p">(</span><span class="n">elem2face</span><span class="p">(</span><span class="n">bdFlag</span><span class="p">(:,</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span> <span class="p">=</span> <span class="n">true</span><span class="p">;</span>
    <span class="n">DirichletFace</span> <span class="p">=</span> <span class="n">face</span><span class="p">(</span><span class="n">isBdFace</span><span class="p">,:);</span>
    <span class="c">% Find outwards normal direction of Neumann boundary faces</span>
    <span class="n">bdFaceOutDirec</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">NF</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">bdFaceOutDirec</span><span class="p">(</span><span class="n">elem2face</span><span class="p">(</span><span class="n">bdFlag</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),:)</span> <span class="p">=</span> <span class="o">-</span><span class="n">Dlambda</span><span class="p">(</span><span class="n">bdFlag</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,:,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">bdFaceOutDirec</span><span class="p">(</span><span class="n">elem2face</span><span class="p">(</span><span class="n">bdFlag</span><span class="p">(:,</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),:)</span> <span class="p">=</span> <span class="o">-</span><span class="n">Dlambda</span><span class="p">(</span><span class="n">bdFlag</span><span class="p">(:,</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,:,</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">bdFaceOutDirec</span><span class="p">(</span><span class="n">elem2face</span><span class="p">(</span><span class="n">bdFlag</span><span class="p">(:,</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),:)</span> <span class="p">=</span> <span class="o">-</span><span class="n">Dlambda</span><span class="p">(</span><span class="n">bdFlag</span><span class="p">(:,</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,:,</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">bdFaceOutDirec</span><span class="p">(</span><span class="n">elem2face</span><span class="p">(</span><span class="n">bdFlag</span><span class="p">(:,</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),:)</span> <span class="p">=</span> <span class="o">-</span><span class="n">Dlambda</span><span class="p">(</span><span class="n">bdFlag</span><span class="p">(:,</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,:,</span><span class="mi">4</span><span class="p">);</span>
<span class="k">end</span>
<span class="c">% normalize the boundary face outwards direction</span>
<span class="n">vl</span> <span class="p">=</span> <span class="nb">sqrt</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">bdFaceOutDirec</span><span class="p">,</span><span class="n">bdFaceOutDirec</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span>
<span class="n">idx</span> <span class="p">=</span> <span class="p">(</span><span class="n">vl</span><span class="o">==</span><span class="mi">0</span><span class="p">);</span>
<span class="n">NeumannFace</span> <span class="p">=</span> <span class="n">face</span><span class="p">(</span><span class="o">~</span><span class="n">idx</span><span class="p">,:);</span>
<span class="n">bdFaceOutDirec</span><span class="p">(</span><span class="n">idx</span><span class="p">,:)</span> <span class="p">=</span> <span class="p">[];</span>
<span class="n">vl</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">=</span> <span class="p">[];</span>
<span class="n">bdFaceOutDirec</span> <span class="p">=</span> <span class="n">bdFaceOutDirec</span><span class="o">./</span><span class="p">[</span><span class="n">vl</span> <span class="n">vl</span> <span class="n">vl</span><span class="p">];</span>
<span class="n">display</span><span class="p">(</span><span class="n">DirichletFace</span><span class="p">);</span>
<span class="n">display</span><span class="p">(</span><span class="n">NeumannFace</span><span class="p">);</span>
<span class="n">display</span><span class="p">(</span><span class="n">bdFaceOutDirec</span><span class="p">);</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>
DirichletFace =

  2�3 uint32 matrix

   2   3   7
   2   6   7


NeumannFace =

  10�3 uint32 matrix

   1   2   3
   1   2   6
   1   3   4
   1   4   8
   1   5   6
   1   5   8
   3   4   7
   4   7   8
   5   6   7
   5   7   8


bdFaceOutDirec =

     0     0    -1
     0    -1     0
     0     0    -1
    -1     0     0
     0    -1     0
    -1     0     0
     0     1     0
     0     1     0
     0     0     1
     0     0     1

</pre>
</div>
</div>

</div>
</div>

</div>
    </div>
  </div>
</body>

 


</html>
